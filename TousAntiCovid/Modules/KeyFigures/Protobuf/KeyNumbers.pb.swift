// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: keynumbers.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Keynumbers_KeyNumbersMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyfigureList: [Keynumbers_KeyNumbersMessage.KeyfigureMessage] = []

  var keyfigureMapList: [Keynumbers_KeyNumbersMessage.KeyfigureMapMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ElementSerieMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var date: UInt32 {
      get {return _date ?? 0}
      set {_date = newValue}
    }
    /// Returns true if `date` has been explicitly set.
    var hasDate: Bool {return self._date != nil}
    /// Clears the value of `date`. Subsequent reads from it will return its default value.
    mutating func clearDate() {self._date = nil}

    var value: Double {
      get {return _value ?? 0}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _date: UInt32? = nil
    fileprivate var _value: Double? = nil
  }

  struct DepartmentValuesMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dptNb: String = String()

    var dptLabel: String = String()

    var extractDate: UInt32 = 0

    var value: Double = 0

    var series: [Keynumbers_KeyNumbersMessage.ElementSerieMessage] = []

    var valueToDisplay: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct KeyfigureMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var category: String = String()

    var isFeatured: Bool {
      get {return _isFeatured ?? false}
      set {_isFeatured = newValue}
    }
    /// Returns true if `isFeatured` has been explicitly set.
    var hasIsFeatured: Bool {return self._isFeatured != nil}
    /// Clears the value of `isFeatured`. Subsequent reads from it will return its default value.
    mutating func clearIsFeatured() {self._isFeatured = nil}

    var displayOnSameChart: Bool {
      get {return _displayOnSameChart ?? false}
      set {_displayOnSameChart = newValue}
    }
    /// Returns true if `displayOnSameChart` has been explicitly set.
    var hasDisplayOnSameChart: Bool {return self._displayOnSameChart != nil}
    /// Clears the value of `displayOnSameChart`. Subsequent reads from it will return its default value.
    mutating func clearDisplayOnSameChart() {self._displayOnSameChart = nil}

    var magnitude: UInt32 = 0

    var isHighlighted: Bool = false

    var chartType: String {
      get {return _chartType ?? String()}
      set {_chartType = newValue}
    }
    /// Returns true if `chartType` has been explicitly set.
    var hasChartType: Bool {return self._chartType != nil}
    /// Clears the value of `chartType`. Subsequent reads from it will return its default value.
    mutating func clearChartType() {self._chartType = nil}

    var limitLine: Double {
      get {return _limitLine ?? 0}
      set {_limitLine = newValue}
    }
    /// Returns true if `limitLine` has been explicitly set.
    var hasLimitLine: Bool {return self._limitLine != nil}
    /// Clears the value of `limitLine`. Subsequent reads from it will return its default value.
    mutating func clearLimitLine() {self._limitLine = nil}

    var labelKey: String = String()

    var valueGlobalToDisplay: String = String()

    var valueGlobal: Double = 0

    var lastUpdate: UInt32 = 0

    var extractDate: UInt32 = 0

    var series: [Keynumbers_KeyNumbersMessage.ElementSerieMessage] = []

    var avgSeries: [Keynumbers_KeyNumbersMessage.ElementSerieMessage] = []

    var version: String = String()

    var valuesDepartments: [Keynumbers_KeyNumbersMessage.DepartmentValuesMessage] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _isFeatured: Bool? = nil
    fileprivate var _displayOnSameChart: Bool? = nil
    fileprivate var _chartType: String? = nil
    fileprivate var _limitLine: Double? = nil
  }

  struct DepartmentValuesMapMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dptNb: String = String()

    var series: [Keynumbers_KeyNumbersMessage.ElementSerieMessage] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct KeyfigureMapMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var labelKey: String = String()

    var version: String = String()

    var valuesDepartments: [Keynumbers_KeyNumbersMessage.DepartmentValuesMapMessage] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "keynumbers"

extension Keynumbers_KeyNumbersMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyNumbersMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyfigureList"),
    2: .same(proto: "KeyfigureMapList"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keyfigureList) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.keyfigureMapList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyfigureList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyfigureList, fieldNumber: 1)
    }
    if !self.keyfigureMapList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyfigureMapList, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keynumbers_KeyNumbersMessage, rhs: Keynumbers_KeyNumbersMessage) -> Bool {
    if lhs.keyfigureList != rhs.keyfigureList {return false}
    if lhs.keyfigureMapList != rhs.keyfigureMapList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keynumbers_KeyNumbersMessage.ElementSerieMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keynumbers_KeyNumbersMessage.protoMessageName + ".ElementSerieMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._date) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keynumbers_KeyNumbersMessage.ElementSerieMessage, rhs: Keynumbers_KeyNumbersMessage.ElementSerieMessage) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keynumbers_KeyNumbersMessage.DepartmentValuesMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keynumbers_KeyNumbersMessage.protoMessageName + ".DepartmentValuesMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dptNb"),
    2: .same(proto: "dptLabel"),
    3: .same(proto: "extractDate"),
    4: .same(proto: "value"),
    5: .same(proto: "series"),
    6: .same(proto: "valueToDisplay"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dptNb) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dptLabel) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.extractDate) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.series) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.valueToDisplay) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dptNb.isEmpty {
      try visitor.visitSingularStringField(value: self.dptNb, fieldNumber: 1)
    }
    if !self.dptLabel.isEmpty {
      try visitor.visitSingularStringField(value: self.dptLabel, fieldNumber: 2)
    }
    if self.extractDate != 0 {
      try visitor.visitSingularUInt32Field(value: self.extractDate, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 4)
    }
    if !self.series.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.series, fieldNumber: 5)
    }
    if !self.valueToDisplay.isEmpty {
      try visitor.visitSingularStringField(value: self.valueToDisplay, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keynumbers_KeyNumbersMessage.DepartmentValuesMessage, rhs: Keynumbers_KeyNumbersMessage.DepartmentValuesMessage) -> Bool {
    if lhs.dptNb != rhs.dptNb {return false}
    if lhs.dptLabel != rhs.dptLabel {return false}
    if lhs.extractDate != rhs.extractDate {return false}
    if lhs.value != rhs.value {return false}
    if lhs.series != rhs.series {return false}
    if lhs.valueToDisplay != rhs.valueToDisplay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keynumbers_KeyNumbersMessage.KeyfigureMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keynumbers_KeyNumbersMessage.protoMessageName + ".KeyfigureMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
    2: .same(proto: "isFeatured"),
    3: .same(proto: "displayOnSameChart"),
    16: .same(proto: "magnitude"),
    4: .same(proto: "isHighlighted"),
    5: .same(proto: "chartType"),
    6: .same(proto: "limitLine"),
    7: .same(proto: "labelKey"),
    8: .same(proto: "valueGlobalToDisplay"),
    9: .same(proto: "valueGlobal"),
    10: .same(proto: "lastUpdate"),
    11: .same(proto: "extractDate"),
    12: .same(proto: "series"),
    13: .same(proto: "avgSeries"),
    14: .same(proto: "version"),
    15: .same(proto: "valuesDepartments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isFeatured) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._displayOnSameChart) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isHighlighted) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._chartType) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self._limitLine) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.labelKey) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.valueGlobalToDisplay) }()
      case 9: try { try decoder.decodeSingularDoubleField(value: &self.valueGlobal) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.lastUpdate) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.extractDate) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.series) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.avgSeries) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.valuesDepartments) }()
      case 16: try { try decoder.decodeSingularUInt32Field(value: &self.magnitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 1)
    }
    try { if let v = self._isFeatured {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._displayOnSameChart {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    if self.isHighlighted != false {
      try visitor.visitSingularBoolField(value: self.isHighlighted, fieldNumber: 4)
    }
    try { if let v = self._chartType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._limitLine {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
    } }()
    if !self.labelKey.isEmpty {
      try visitor.visitSingularStringField(value: self.labelKey, fieldNumber: 7)
    }
    if !self.valueGlobalToDisplay.isEmpty {
      try visitor.visitSingularStringField(value: self.valueGlobalToDisplay, fieldNumber: 8)
    }
    if self.valueGlobal != 0 {
      try visitor.visitSingularDoubleField(value: self.valueGlobal, fieldNumber: 9)
    }
    if self.lastUpdate != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastUpdate, fieldNumber: 10)
    }
    if self.extractDate != 0 {
      try visitor.visitSingularUInt32Field(value: self.extractDate, fieldNumber: 11)
    }
    if !self.series.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.series, fieldNumber: 12)
    }
    if !self.avgSeries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.avgSeries, fieldNumber: 13)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 14)
    }
    if !self.valuesDepartments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.valuesDepartments, fieldNumber: 15)
    }
    if self.magnitude != 0 {
      try visitor.visitSingularUInt32Field(value: self.magnitude, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keynumbers_KeyNumbersMessage.KeyfigureMessage, rhs: Keynumbers_KeyNumbersMessage.KeyfigureMessage) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs._isFeatured != rhs._isFeatured {return false}
    if lhs._displayOnSameChart != rhs._displayOnSameChart {return false}
    if lhs.magnitude != rhs.magnitude {return false}
    if lhs.isHighlighted != rhs.isHighlighted {return false}
    if lhs._chartType != rhs._chartType {return false}
    if lhs._limitLine != rhs._limitLine {return false}
    if lhs.labelKey != rhs.labelKey {return false}
    if lhs.valueGlobalToDisplay != rhs.valueGlobalToDisplay {return false}
    if lhs.valueGlobal != rhs.valueGlobal {return false}
    if lhs.lastUpdate != rhs.lastUpdate {return false}
    if lhs.extractDate != rhs.extractDate {return false}
    if lhs.series != rhs.series {return false}
    if lhs.avgSeries != rhs.avgSeries {return false}
    if lhs.version != rhs.version {return false}
    if lhs.valuesDepartments != rhs.valuesDepartments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keynumbers_KeyNumbersMessage.DepartmentValuesMapMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keynumbers_KeyNumbersMessage.protoMessageName + ".DepartmentValuesMapMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dptNb"),
    2: .same(proto: "series"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dptNb) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.series) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dptNb.isEmpty {
      try visitor.visitSingularStringField(value: self.dptNb, fieldNumber: 1)
    }
    if !self.series.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.series, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keynumbers_KeyNumbersMessage.DepartmentValuesMapMessage, rhs: Keynumbers_KeyNumbersMessage.DepartmentValuesMapMessage) -> Bool {
    if lhs.dptNb != rhs.dptNb {return false}
    if lhs.series != rhs.series {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Keynumbers_KeyNumbersMessage.KeyfigureMapMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Keynumbers_KeyNumbersMessage.protoMessageName + ".KeyfigureMapMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labelKey"),
    2: .same(proto: "version"),
    3: .same(proto: "valuesDepartments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.labelKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.valuesDepartments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labelKey.isEmpty {
      try visitor.visitSingularStringField(value: self.labelKey, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.valuesDepartments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.valuesDepartments, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keynumbers_KeyNumbersMessage.KeyfigureMapMessage, rhs: Keynumbers_KeyNumbersMessage.KeyfigureMapMessage) -> Bool {
    if lhs.labelKey != rhs.labelKey {return false}
    if lhs.version != rhs.version {return false}
    if lhs.valuesDepartments != rhs.valuesDepartments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
